"""Possibles Branch points of the symbolic execution tree that the 
symbolic execution can take.
"""


class BranchPoint:
    """Branch point abstract class.
    """

    def get_branch(self):
        """Returns the current value of the branch point
        """
        raise NotImplementedError

    def all_branches_covered(self):
        """ Tells whether the branch point is fully covered or not.

        Returns:
            True if all possible branches of this branch point were covered, and
            if all the subsequent branch points generated by these decisions
            have also been fully covered, False otherwise.
        """
        raise NotImplementedError

    def advance_branch(self):
        """ Set the value of this branch point to the next one.
        """
        raise NotImplementedError


class ConditionalBranchPoint(BranchPoint):
    """Conditional branch point.

    Stores and retrieves the information about the value taken on
    branch point due to a path constraint. The value Taken can be
    either True or False.

    Attributes:
        unique: its value is True is this branch Point is unique, that is
        if there is only one possible value.

        current_branch: The current value of the branch point. (True or False)

        fully_covered: True if this branch point has been covered by both
        possibilities (True and False), and if all the subsequent branching
        points generated by these decisions have also been fully covered. False
        otherwise.

    """

    def __init__(self, value=None):
        if value is not None:
            self.unique = True
            self.current_branch = value
        else:
            self.unique = False
            self.current_branch = True
        self.fully_covered = False

    def get_branch(self):
        return self.current_branch

    def all_branches_covered(self):
        return self.fully_covered

    def advance_branch(self):
        """ Set the value of this branch point to the next one.

        Transitions:
            - True -> False
            - False -> Fully Covered.

        """
        if self.unique:
            self.fully_covered = True
        else:
            if self.current_branch:
                self.current_branch = False
            else:
                self.fully_covered = True

    def __repr__(self):
        return str(self.current_branch)


class LazyBranchPoint(BranchPoint):
    """Lazy Initialization branch point.

    Stores and retrieves the information about the value taken on
    branch point due to a lazy initialization step. The value Taken is
    an integer that represents all lazy initializations possibilities.
     - 0:         A brand new structure.
     - 1:         None.
     - [2 - number_of_branches]:  A previously created structure.

    Attributes:
        number_of_branches: represents all the initialization possibilities.
        current_branch: The current taken lazy initialization choice.
    """

    def __init__(self, branches):
        self.number_of_branches = branches
        self.current_branch = 0

    def get_branch(self):
        return self.current_branch

    def all_branches_covered(self):
        return self.current_branch > self.number_of_branches

    def advance_branch(self):
        self.current_branch += 1

    def __repr__(self):
        return str(self.number_of_branches)
