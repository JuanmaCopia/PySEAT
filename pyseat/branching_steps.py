"""Possibles Branching Steps that the symbolic execution can take.

"""


class ConditionalBranchPoint:
    """Conditional branching step.

    Stores and retrieves the information about the value taken on
    branching point due to a path constraint. The value Taken can be
    either True or False.

    Attributes:
        bool_value: The taken value of the branching point.

        fully_covered: True if this branching point has been covered by both
        possibilities (True and False), and if all the subsequent branching
        points generated by these decisions have also been fully covered. False
        otherwise.

    """

    def __init__(self, value=None):
        if value is not None:
            self.unique = True
            self.bool_value = value
        else:
            self.unique = False
            self.bool_value = True
        self.fully_covered = False

    def get_branch(self):
        """Returns the current value (or the "taken" value).
        """
        assert not self.all_branches_covered()
        return self.bool_value

    def all_branches_covered(self):
        """ Tells whether the branchin point is fully covered or not.

        Returns:
            True if fully covered, False otherwise.
        """
        return self.fully_covered

    def advance_branch(self):
        """ Set the value of this branching point to the next one.

        Transitions:
            - True -> False
            - False -> Fully Covered.

        """
        if self.unique:
            self.fully_covered = True
        else:
            if self.bool_value:
                self.bool_value = False
            else:
                self.fully_covered = True

    def is_lazy_step(self):
        """ Tells whether is a lazy step or not.
        """
        return False


class LazyBranchPoint:
    """Lazy Initialization branching step.

    Stores and retrieves the information about the value taken on
    branching point due to a lazy initialization. The value Taken is
    an integer that represents all lazy initializations possibilities.
     - 0:         A brand new structure.
     - 1:         None.
     - [2 - number_of_branches]:  A previously created structure.

    Attributes:
        number_of_branches: represents all the initialization possibilities.
        current_branch: The current taken lazy initialization choice.
    """

    def __init__(self, branches):
        self.number_of_branches = branches
        self.current_branch = 0

    def get_branch(self):
        """Returns the current value (or the "taken" value).
        """
        assert not self.all_branches_covered()
        return self.current_branch

    def all_branches_covered(self):
        """ Tells whether the branchin point is fully covered or not.

        Returns:
            True if this branching point has been covered by all lazy
            initialization possibilities, and if all the subsequent branching
            points generated by these decisions have also been fully covered, False
            otherwise.

        """
        return self.current_branch > self.number_of_branches

    def advance_branch(self):
        """ Set the value of this branching point to the next one.
        """
        self.current_branch += 1

    def is_lazy_step(self):
        """ Tells whether is a lazy step or not.
        """
        return True

