"""Posible Branching Steps that the symbolic execution can take.

"""


class Path:
    def __init__(self):
        self._branch_points = []
        self._current_bp = 0

    def add_new_lazy_branch_point(self, num_branches):
        self._branch_points.append(LazyStep(num_branches))
        self._current_bp += 1

    def add_new_cond_branch_point(self, num_branches):
        self._branch_points.append(ConditionalStep(num_branches))
        self._current_bp += 1

    def advance_last_branch(self):
        self._branch_points[-1].advance_branch()

    def get_current_branch(self):
        self._branch_points[self._current_bp].get_branch()

    def exists_branch(self):
        return self._current_bp < len(self._branch_points)

    def reset_path(self):
        self._current_bp = 0

    def set_next_path(self):
        if not self._branch_points:
            return None
        last_bp = self._branch_points[-1]
        last_bp.advance_branch()

        while self._branch_points and last_bp.all_branches_covered():
            del self._branch_points[-1]
            if self._branch_points:
                last_bp = self._branch_points[-1]
                last_bp.advance_branch()


class ConditionalStep:
    """Conditional branching step.

    Stores and retrieves the information about the value taken on
    branching point due to a path constraint. The value Taken can be
    either True or False.

    Attributes:
        bool_value: The taken value of the branching point.

        fully_covered: True if this branching point has been covered by both
        possibilities (True and False), and if all the subsequent branching
        points generated by these desitions have also been fully covered. False
        otherwise.

    """

    def __init__(self):
        self.bool_value = True
        self.fully_covered = False

    def get_branch(self):
        """Returns the current value (or the "taken" value).
        """
        assert not self.all_branches_covered()
        return self.bool_value

    def all_branches_covered(self):
        """ Tells whether the branchin point is fully covered or not.

        Returns:
            True if fully covered, False otherwise.
        """
        return self.fully_covered

    def advance_branch(self):
        """ Set the value of this branching point to the next one.

        Transitions:
            - True -> False
            - False -> Fully Covered.

        """
        if self.bool_value:
            self.bool_value = False
        else:
            self.fully_covered = True

    def is_lazy_step(self):
        """ Tells whether is a lazy step or not.
        """
        return False


class LazyStep:
    """Lazy Initialization branching step.

    Stores and retrieves the information about the value taken on
    branching point due to a lazy initialization. The value Taken is
    an integer that represents all lazy initializations possibilities.
     - 0:         None.
     - [1, n-1]:  A previously created structure.
     - n:         A brand new structure.
    Where n is the length of the lazy initialization vector. Represented
    by the attribute number_of_branches

    Attributes:
        number_of_branches: length of the lazy initialization vector, represents
        all the initialization possibilities.

        current_branch: The current taken lazy initialization choice.

    """

    def __init__(self, branches):
        self.number_of_branches = branches
        self.current_branch = 0

    def get_branch(self):
        """Returns the current value (or the "taken" value).
        """
        assert not self.all_branches_covered()
        return self.current_branch

    def all_branches_covered(self):
        """ Tells whether the branchin point is fully covered or not.

        Returns:
            True if this branching point has been covered by all lazy
            initialization possibilities, and if all the subsequent branching
            points generated by these desitions have also been fully covered, False
            otherwise.

        """
        return self.current_branch > self.number_of_branches

    def advance_branch(self):
        """ Set the value of this branching point to the next one.
        """
        self.current_branch += 1

    def is_lazy_step(self):
        """ Tells whether is a lazy step or not.
        """
        return True

